-- QUERY 1

-- Query to find all multi-day events
SELECT * FROM event WHERE days(enddate) - days(startdate) > 0 ORDER BY startdate ASC, title ASC

-- Pretty print the above query
SELECT eid, CAST(title AS VARCHAR(30)), CAST(description AS VARCHAR(20)), startdate, enddate, organizer, postcode FROM event WHERE days(enddate) - days(startdate) > 0 ORDER BY startdate ASC, title ASC

-- Clarifications:
The `days(enddate) - days(startdate)` part returns the number of days between
enddate and startdate. If the number of days is greater than 0, then the enddate
and startdate are not the same, which means that the event is a multi-day event.
We will select all the columns in the table event whose rows satisfy the above
condition. `ORDER BY startdate` will order the result by increasing startdate and
`title ASC` will order the result in alphabetical order on title in case the
events have the same startdate.


-- QUERY 2

SELECT eid, title FROM event WHERE postcode in (SELECT postcode FROM region WHERE name = 'Golden Horseshoe') ORDER BY title ASC

-- Clarifications:
`SELECT postcode FROM region WHERE name = 'Golden Horseshoe'` will return a
"list" of postal codes that are in the region named Golden Horseshoe. Thus,
`SELECT eid, title FROM event WHERE postcode in (SELECT postcode FROM region WHERE name = 'Golden Horseshoe')`
will return the columns eid and title of the table event whose event's postal code
is in the  above list. `ORDER BY title ASC` orders the result in alphabetical
order in title.


-- QUERY 3

-- All the users that have written review
SELECT uid, name FROM user WHERE uid IN (SELECT user FROM review) AND uid NOT IN (SELECT organizer FROM event)

-- Clarifications:
A user is active (have written a review) is the user whose uid is in the review,
that is the uid is in the user column of the table review. Thus, `uid IN (SELECT user FROM review)`
is a condition for the query. A user who is not the organizer of any events is
the user whose uid does not appear in the organizer column of the table event.
Thus, `uid NOT IN (SELECT organizer FROM event)` is the second condition for the
query. We then, only select the uid and name columns of the resulting table.
Since this query does not require ordering, we do not use `ORDER BY`.


-- QUERY 4

---- Pretty print the review
SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review

---- event id, the number of reviews, the average score
SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event


a)
-- QUERY 4a)
SELECT eid, title, description, startdate, enddate, organizer, postcode, nrev, ascore
FROM event LEFT OUTER JOIN 
        (SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore
        FROM review
        GROUP BY event) AS r
     ON event.eid = r.event
ORDER BY ascore DESC, title ASC

-- One line Query
SELECT eid, title, description, startdate, enddate, organizer, postcode, nrev, ascore FROM event LEFT OUTER JOIN (SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event) AS r ON event.eid = r.event ORDER BY ascore DESC, title ASC

-- Pretty print the query
SELECT eid, CAST(title AS VARCHAR(28)) AS title, CAST(description AS VARCHAR(12)) AS description, startdate, enddate, organizer, postcode, nrev, ascore FROM event LEFT OUTER JOIN (SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event) AS r ON event.eid = r.event ORDER BY ascore DESC, title ASC

-- Clarifications:
`SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event`
will group the reviews by event id (eid) from the table review and show the event
id, the number of reviews for each event and the average score of the reviews for
each event. Then, we join the table event with this resulting table and match the
rows where the eid of table event equals to the event column of the above
resulting table. `LEFT OUTER JOIN` is used to also include events that have no 
review. After that, select the appropriate columns and order the rows
by decreasing average score and alphabetical order in title in case of events
having the same score.


b)
-- QUERY 4b)
SELECT eid, title, description, startdate, enddate, organizer, postcode, nrev, ascore
FROM event INNER JOIN 
        (SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore 
        FROM review
        GROUP BY event
        HAVING COUNT(*) >= 5) AS r 
     ON event.eid = r.event
ORDER BY ascore DESC, title ASC

-- One line Query
SELECT eid, title, description, startdate, enddate, organizer, postcode, nrev, ascore FROM event INNER JOIN (SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event HAVING COUNT(*) >= 5) AS r ON event.eid = r.event ORDER BY ascore DESC, title ASC

-- Pretty print the query
SELECT eid, CAST(title AS VARCHAR(28)) AS title, CAST(description AS VARCHAR(12)) AS description, startdate, enddate, organizer, postcode, nrev, ascore FROM event INNER JOIN (SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event HAVING COUNT(*) >= 5) AS r ON event.eid = r.event ORDER BY ascore DESC, title ASC

-- Clarifications:
Similar to part a) but we have `HAVING COUNT(*) >= 5` after 
`SELECT event, COUNT(*) AS nrev, AVG(score) AS ascore FROM review GROUP BY event`
to only include events with at least 5 reviews. Since we only include events with
at least 5 reviews, we used `INNER JOIN` instead of `LEFT OUTER JOIN`.


-- QUERY 5

-- Query
SELECT e.eid, e.title
FROM event AS e INNER JOIN review AS r
ON e.eid = r.event AND (r.reviewdate < e.startdate OR r.user = e.organizer)

-- One line Query
SELECT e.eid, e.title FROM event AS e INNER JOIN review AS r ON e.eid = r.event AND (r.reviewdate < e.startdate OR r.user = e.organizer)

-- Pretty print for testing
SELECT e.eid, CAST(e.title AS VARCHAR(25)) AS title, CAST(e.description AS VARCHAR(12)) AS eventdescription, e.startdate, e.enddate, e.organizer, e.postcode, r.user, r.event, CAST(r.description AS VARCHAR(20)) AS reviewdescription, r.score, r.reviewdate FROM event AS e INNER JOIN review AS r ON e.eid = r.event AND (r.reviewdate < e.startdate OR r.user = e.organizer)

-- Clarifications:
We will join the table event and the table review. Then, we only select rows
where first, the eid (of the table event) is the same as the event (of the table
review). Then, the row is selected if either the reviewdate is smaller than the
startdate (the review is written before the start of the event) or the review
user is the same as the event organizer.


-- QUERY 6 - NOT DONE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- Display the user and the region they are in
SELECT u.uid, CAST(u.name AS VARCHAR(10)) AS user_name, u.postcode, CAST(re.name AS VARCHAR(30)) AS region_name FROM user AS u INNER JOIN region AS re ON u.postcode = re.postcode

-- Display the event and the region the event happens in
SELECT e.eid, CAST(e.title AS VARCHAR(25)) AS title, e.postcode, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode

-- Display review user, review event and event region name
SELECT r.user, r.event, e_re.region_name FROM review AS r INNER JOIN (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re ON r.event = e_re.eid

-- Display review and postcode of the event in the review
SELECT r.user, r.event, e.postcode FROM review AS r INNER JOIN event AS e ON r.event = e.eid



-- QUERY 7 - NOT DONE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- Display event id (eid) and keyword associated with the event
SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event

-- Main Query
SELECT DISTINCT e1.eid AS fstid, e2.eid AS sndid FROM (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS e1 INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS e2 ON e1.eid <> e2.eid AND (SELECT word FROM (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event)) = (SELECT word FROM (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event)) ORDER BY fstid ASC, sndid ASC

-- Clarifications:
`SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event`
will return a table with the event id and the keywords associated with the events.
We will join the table with itself and only select the events where the even id
(eid) of the first table is different from the event id (eid) from the second
table (select two different events) and the keywords are exactly the same between


-- QUERY 8

-- Display the event and the popularity score (number of reviews + sum of the reviews)
SELECT event, COUNT(*) + SUM(score) AS pscore FROM review GROUP BY event

a)
-- 
SELECT e.eid, e_re.pscore FROM event AS e LEFT OUTER JOIN (SELECT event, COUNT(*) + SUM(score) AS pscore FROM review GROUP BY event) AS e_re ON e.eid = e_re.event ORDER BY e_re.pscore DESC, e.title ASC

-- Clarifications:
`SELECT event, COUNT(*) + SUM(score) AS pscore FROM review GROUP BY event` will
group the reviews for the same event together and return the event id along with
its popularity score pscore (calculated by the number of review plus the sum of
all the reivew score for that event). We name this table e_re. Then we join the
table event with the table e_re. `LEFT OUTER JOIN` is used since we want to display
all the events (even if the event does not have any review). Then we choose the
rows where the event eid is equal to the event column of the table e_re. After
that, we select the eid column and the pscore column.


b)
-- Query
SELECT e.eid, e.title, e_re.pscore FROM event AS e INNER JOIN (SELECT event, COUNT(*) + SUM(score) AS pscore FROM review GROUP BY event) AS e_re ON e.eid = e_re.event AND e_re.pscore >= ALL (SELECT COUNT(*) + SUM(score) FROM review GROUP BY event) ORDER BY e_re.pscore DESC, e.title ASC

-- Pretty print the query
SELECT e.eid, CAST(e.title AS VARCHAR(30)), e_re.pscore FROM event AS e INNER JOIN (SELECT event, COUNT(*) + SUM(score) AS pscore FROM review GROUP BY event) AS e_re ON e.eid = e_re.event AND e_re.pscore >= ALL (SELECT COUNT(*) + SUM(score) FROM review GROUP BY event) ORDER BY e_re.pscore DESC, e.title ASC

-- Clarifications:
Similar to query 8a) but `INNER JOIN` is used since we only want to display
certain events instead of all the events.
`e_re.pscore >= ALL (SELECT COUNT(*) + SUM(score) FROM review GROUP BY event)`
will select the highest number in the column pscore. Then, we select the eid
column, the title, and the pscore of the events that satisfy the conditions.


-- QUERY 9

-- PART 1

---- Pretty print the review
SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review

-- Display event id (eid) and keyword associated with the event
SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event

-- Display the user id, the event id, and the keywords associated with the event.
SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid

-- Display the user id, the keyword and the number of times the user review an even
-- with that keyword
-- by taking the above query and group by user, word
SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word

-- Display the keyword and the max number of reviews associated with that keyword
SELECT word, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) GROUP BY word

-- Display the user, the keyword, and the max number of reviews associated with
-- that keyword
-- by join the above two tables on the same keywords and the same number of
-- reviews associated with that keyword
SELECT "USER", a.word, max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) AS a INNER JOIN (SELECT word, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) GROUP BY word) AS b ON a.word = b.word AND a.nrevs = b.max_nrevs

-- Display the uid and the literal string 'keyword'
SELECT uid, 'keyword' AS kword FROM USER

-- Display the uid and the literal string 'keyword' for user with the most number
-- of reviews for the events with some specific keyword
-- by joining the above two tables on the uid = user columns.
SELECT DISTINCT uid, kword FROM (SELECT uid, 'keyword' AS kword FROM USER) AS a INNER JOIN (SELECT "USER", a.word, max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) AS a INNER JOIN (SELECT word, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) GROUP BY word) AS b ON a.word = b.word AND a.nrevs = b.max_nrevs) AS b ON a.uid = b.user


-- PART 2

-- Display the event id and the region the event happens in
SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode

-- Display the user id and the event id from the table review
SELECT "USER", event FROM review

-- Display the user id, the event id and the region the event happens in
-- by join the above two tables on the same event id
SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event

-- Display the user id, the region name of the event and the number of reviews
-- that user has reviewed for events at that region
-- using group by user id and region_name from the above table
SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name

-- Display the region name of the events and the max number of reviews associated
-- with that region
SELECT region_name, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) GROUP BY region_name

-- Display the user id, the region name of the event and the max number of reviews
-- associated with that region
-- by joining the above two tables on the same region and the number of reviews
-- = max number of reviews associated with that region
SELECT "USER", a.region_name, max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) AS a INNER JOIN (SELECT region_name, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) GROUP BY region_name) AS b ON a.region_name = b.region_name AND a.nrevs = b.max_nrevs

-- Display the user uid and the literal string 'region' from table user
SELECT uid, 'region' AS region_badge FROM user

-- Display the uid and the literal string 'keyword' for user with the most number
-- of reviews for the events within a region
-- by joining the above two tables on the uid = user columns.
SELECT DISTINCT uid, region_badge FROM (SELECT uid, 'region' AS region_badge FROM user) AS u INNER JOIN (SELECT "USER", a.region_name, max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) AS a INNER JOIN (SELECT region_name, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) GROUP BY region_name) AS b ON a.region_name = b.region_name AND a.nrevs = b.max_nrevs) AS b ON u.uid = b.user


-- PART 3: FINAL QUERY
-- Union the last two tables from part 1 and part 2
(SELECT DISTINCT uid, kword FROM (SELECT uid, 'keyword' AS kword FROM USER) AS a INNER JOIN (SELECT "USER", a.word, max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) AS a INNER JOIN (SELECT word, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", word, COUNT(*) AS nrevs FROM (SELECT "USER", event, word FROM (SELECT "USER", event, CAST(description AS VARCHAR(30)) AS description, score, reviewdate FROM review) AS r INNER JOIN (SELECT e.eid, k.word FROM event AS e INNER JOIN keyword AS k ON e.eid = k.event) AS ek ON r.event = ek.eid) GROUP BY "USER", word) GROUP BY word) AS b ON a.word = b.word AND a.nrevs = b.max_nrevs) AS b ON a.uid = b.user) UNION (SELECT DISTINCT uid, region_badge FROM (SELECT uid, 'region' AS region_badge FROM user) AS u INNER JOIN (SELECT "USER", a.region_name, max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) AS a INNER JOIN (SELECT region_name, MAX(nrevs) AS max_nrevs FROM (SELECT "USER", region_name, COUNT(*) AS nrevs FROM (SELECT "USER", event, region_name FROM (SELECT e.eid, CAST(re.name AS VARCHAR(30)) AS region_name FROM event AS e INNER JOIN region AS re ON e.postcode = re.postcode) AS e_re INNER JOIN (SELECT "USER", event FROM review) AS r ON e_re.eid = r.event) GROUP BY "USER", region_name) GROUP BY region_name) AS b ON a.region_name = b.region_name AND a.nrevs = b.max_nrevs) AS b ON u.uid = b.user)




